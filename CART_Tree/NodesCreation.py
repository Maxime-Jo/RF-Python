"""Test output"""# Load data#from sklearn.datasets import load_boston#X, y = load_boston(return_X_y=True)"""In this script, we are looking at the tree construction. This script is highly dependent on the best split search. The inputs arethe cut function/class, the covariates and the response.The approach is following the idea of the HeapTree - especially, the fact that a node has two children which are n*2 and n2+1.The class will visit each node one after the other. The strategy is then a breath first search approach.We have as output the tree's construction sequence (i.e, each time we are adding a new layer in the matrix that allocate the observationsto a final leave). Here, we need to insert in the new sequence the id for the two new nodes only.Additionnally, since we have building constraints (e.g., min leaf size), we might skip the construction of a node.We stop the construction of the tree when we have visited all nodes.Sometime, the next node does not exist since a constraint blocked its construction. We need to intorduce a while loop in order tovisit the next existing one.""""""Class Start"""import numpy as npnp.random.seed(10)  # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                    # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                    # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!class NodeSearch():                def breath_first_search(self, X, y, min_bucket = 5):                y_records = np.random.randint(0,1,len(y)) + 1           # initialise tree records        y_records = np.transpose(np.array([y_records]))                cut_level = 1                                           # initialise tree level                father_X = X                                            # initialise parents        mother_y = y                                            # initialise parents                stopping_criteria = False                             while stopping_criteria == False:                        child_1 = cut_level*2            child_2 = child_1 + 1            vector_size = len(mother_y)                        cut = np.random.randint(1,vector_size,1)[0] # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                                                        # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                                                        # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                                                        # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                                                        # TO BE CHANGED - TMP - MIMIC CUT !!!!!!!!                        bucket_1 = [child_1]*cut            bucket_2 = [child_2]*(vector_size-cut)                        if min(len(bucket_1),len(bucket_2)) >= min_bucket:                            cut_record = np.array(bucket_1 + bucket_2)                                          # create the two news branches                            min_index = np.squeeze(np.where(y_records[:,-1]==cut_level)).min()                  # we need to re-insert the branches                                                                                                                max_index = np.squeeze(np.where(y_records[:,-1]==cut_level)).max()                  # looking at where to insert                                                    left = y_records[np.squeeze(np.where(y_records[:,-1])<min_index),-1]                # get the left and the right records                right = y_records[np.squeeze(np.where(y_records[:,-1]))>max_index,-1]               # for insertion                            new_record = np.concatenate((left, cut_record, right))                              # new record of the tree                            y_records = np.concatenate((y_records, np.transpose([new_record])), axis = 1)       # insert into the full records                                                max_child_id = y_records[:,-1].max()                                                    # continue until reach last node                                    cut_level += 1                         if cut_level == max_child_id:                                                           # stopping criteria                stopping_criteria = True                                        cut_level_decision = False                                                              # since have minimum bucket                                                                                                    # we can cancel some nodes                                                                                                    # need to force the visit of                                                                                                    # the next one                                                                                                    # un-less we reach final one                                                                                                    # "ceinture-bretelle"            while cut_level_decision == False:                  if sum(y_records[:,-1]==cut_level) == 0:                    # HERE, if mother become empty                    cut_level += 1                                                        else :                     cut_level_decision = True                                                       # get to the next level                                if cut_level == max_child_id:                      stopping_criteria = True                    cut_level_decision = True                         father_X = X[y_records[:,-1]==cut_level,:]                                              # update the new parents                mother_y = y[y_records[:,-1]==cut_level]                        print(len(mother_y))                    return y_records                """Test output"""#NS = NodeSearch()#test = NS.breath_first_search(X, y)#y_records = test